---
title: 二分查找
toc: true
recommend: 1
uniqueId: '2020-07-17 13:20:44/"二分查找".html'
date: 2020-07-17 21:20:44
thumbnail:
categories:
tags:
keywords:
---

[TOC]



[二分查找 - 力扣（LeetCode）](https://leetcode-cn.com/tag/binary-search/)

<!--more-->

其实只要**注意边界问题，不陷入死循环**，基本就能解题，根本不用看超长的题解，还有什么超长的打油诗

## 简单

### 面试题 10.05. 稀疏数组搜索 - 力扣（LeetCode）

[面试题 10.05. 稀疏数组搜索 - 力扣（LeetCode）](https://leetcode-cn.com/problems/sparse-array-search-lcci/submissions/)

```python
class Solution:
    def findString(self, words: List[str], s: str) -> int:
        l, r = 0, len(words)-1
        while l<=r:
            mid = (l+r)//2
            while words[mid]=='' and mid<r:
                mid += 1
            if words[mid]=='': r = (l+r)//2-1 # [mid'~r] 都是 ''
            elif words[mid]>s: r = (l+r)//2-1 # [mid'~mid-1] 都是 ''
            elif words[mid]<s: l = mid+1
            else: return mid
        return -1
```



### 374. 猜数字大小 - 力扣（LeetCode）

[374. 猜数字大小 - 力扣（LeetCode）](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

```python
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -> int:

class Solution:
    def guessNumber(self, n: int) -> int:
        l, r = 0, n
        while l<=r:
            mid = (l+r)//2
            if guess(mid)==0: return mid
            elif guess(mid)==1: l = mid+1
            else: r = mid-1

```

### 367. 有效的完全平方数 - 力扣（LeetCode）

[367. 有效的完全平方数 - 力扣（LeetCode）](https://leetcode-cn.com/problems/valid-perfect-square/)

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l, r = 1, num//2
        while l<=r:
            mid = (l+r)//2
            multiply = mid*mid
            if multiply==num: return True
            elif multiply>num: r = mid-1
            else: l = mid+1
        return False if num!=1 else True
```

### 852. 山脉数组的峰顶索引 - 力扣（LeetCode）

[852. 山脉数组的峰顶索引 - 力扣（LeetCode）](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

```python
class Solution:
    def peakIndexInMountainArray(self, a: List[int]) -> int:
        # 找出第一个比右边相邻数大的位置
        l, r = 0, len(a)-1
        # 0 1 2 3 4 5 4 3 2 1 0
        while l<=r:
            mid = (l+r)>>1
            if a[mid]<a[mid+1]: l = mid+1
            else: r = mid-1
        return l

```

### 1237. 找出给定方程的正整数解 - 力扣（LeetCode）

[1237. 找出给定方程的正整数解 - 力扣（LeetCode）](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/)

```python
"""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       # Returns f(x, y) for any given positive integers x and y.
       # Note that f(x, y) is increasing with respect to both x and y.
       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)
       def f(self, x, y):
  
"""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        # 相当于在一个 sorted matrix 里寻找 target 的位置
        res = []
        for i in range(1, 1001):
            l, r = 1, 1000
            while l<=r:
                mid = (l+r)>>1
                fres = customfunction.f(i, mid)
                if fres==z:
                    res.append([i, mid])
                    break
                elif fres>z: r = mid-1
                else: l = mid+1
        return res
```

### 1351. 统计有序矩阵中的负数 - 力扣（LeetCode）

[1351. 统计有序矩阵中的负数 - 力扣（LeetCode）](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/submissions/)

```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        # [[4,3,2,-1],
        #  [3,2,1,-1],
        #  [1,1,-1,-2],
        #  [-1,-1,-2,-3]]
        n, m = len(grid), len(grid[0])
        res = 0
        l = 0 # l 从下到上递增, 故保存
        for i in reversed(range(n)):
            r = m-1
            while l<=r:
                if grid[i][l]<0: break
                mid = (l+r)>>1
                if grid[i][mid]>=0: l = mid+1
                elif grid[i][mid]<0: r = mid
                else: r -= 1
            res += m-l
        return res


```

### 744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）

[744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/submissions/)

```python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        l, r = 0, len(letters)-1
        while l<=r:
            if letters[l]>target: return letters[l]
            mid = (l+r)>>1
            if letters[mid]>target: r = mid
            elif letters[mid]<=target: l = mid+1
        return letters[0]
```

### 1337. 方阵中战斗力最弱的 K 行 - 力扣（LeetCode）

[1337. 方阵中战斗力最弱的 K 行 - 力扣（LeetCode）](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/submissions/)

```python
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        h = [] # 存放 (战斗力, i)
        n, m = len(mat), len(mat[0])
        for i in range(n):
            l, r = 0, m-1
            while True:
                mid = (l+r)//2
                if r==-1 or mat[i][r]==1: break
                else: r -= 1
                if mat[i][mid]==0: r=mid-1
                elif mat[i][mid]==1: l=mid
            h.append((r, i))
        return [i[1] for i in heapq.nsmallest(k, h, key=operator.itemgetter(0, 1))]
```

```python
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        # functools.cpm_to_key
        # heapq.nsmallest(n, h, key=..)
        h = [] # 存放 (战斗力, i)
        n, m = len(mat), len(mat[0])
        for i in range(n):
            l, r = 0, m-1
            while True:
                mid = (l+r)//2
                if r==-1 or mat[i][r]==1: break
                else: r -= 1
                if mat[i][mid]==0: r=mid-1
                elif mat[i][mid]==1: l=mid
            # heapq.heappush(h, (r, i))
            h.append((r, i))
        # print(h)
        # def mykey(a, b):
        #     if a[0]!=b[0]: return a[0]-b[0]
        #     return a[1]-b[1]
        # return [i[1] for i in heapq.nsmallest(k, h, key=functools.cmp_to_key(mykey))]
        return [i[1] for i in heapq.nsmallest(k, h, key=operator.itemgetter(0, 1))]
```

### 704. 二分查找 - 力扣（LeetCode）

[704. 二分查找 - 力扣（LeetCode）](https://leetcode-cn.com/problems/binary-search/submissions/)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)-1
        while l<=r:
            mid = (l+r)//2
            if nums[mid]==target: return mid
            elif nums[mid]>target: r = mid-1
            elif nums[mid]<target: l = mid+1
        return -1
```

### 441. 排列硬币 - 力扣（LeetCode）

[441. 排列硬币 - 力扣（LeetCode）](https://leetcode-cn.com/problems/arranging-coins/submissions/)

```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        # 1~n = (n+1)*n/2
        l, r = 0, n
        def satisfy(n, k):
            return n>=(k+1)*k/2
        while l<=r:
            mid = l+(r-l)//2
            if satisfy(n, r): return r
            r -= 1
            if satisfy(n, mid): l = mid
            else: r = mid-1
        
```



