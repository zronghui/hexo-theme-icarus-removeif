---
title: tricks-2020-09
toc: true
recommend: 1
uniqueId: '2020-09-08 15:45:17/"tricks-2020-09".html'
encrypt: true
password: 1
abstract: 咦，这是一篇加密文章，好像需要输入密码才能查看呢！
message: 嗨，请准确无误地输入密码查看哟
wrong_pass_message: 不好意思，密码没对哦，在检查检查呢！
wrong_hash_message: 不好意思，信息无法验证！
date: 2020-09-08 23:45:17
thumbnail:
categories:
tags:
keywords:
---



[TOC]

<!--more-->



# 编程

### ***LeetcodeTop

[afatcoder/LeetcodeTop: 汇总各大互联网公司容易考察的高频leetcode题🔥](https://github.com/afatcoder/LeetcodeTop)

如果我早点看到的话就好了

## Python



### django admin: django-baton 

[otto-torino/django-baton: A cool, modern and responsive django admin application based on bootstrap 4.5.0 - https://otto-torino.github.io/django-baton](https://github.com/otto-torino/django-baton?utm_campaign=Django%2BNewsletter&utm_medium=rss&utm_source=Django_Newsletter_40)

### aima-python

[aimacode/aima-python: Python implementation of algorithms from Russell And Norvig's "Artificial Intelligence - A Modern Approach"](https://github.com/aimacode/aima-python)

python 实现的各种高级算法

### *streamlit

用极短的 Python 代码编写数据展示项目

[streamlit/streamlit: Streamlit — The fastest way to build data apps in Python](https://github.com/streamlit/streamlit)
[Welcome to Streamlit — Streamlit 0.66.0 documentation](https://docs.streamlit.io/en/stable/)

### jazzit 程序运行中或出错时播放音乐

[Sangarshanan/jazzit: Laughs at your expense](https://github.com/sangarshanan/jazzit)

### ***BeeWare

[Tutorial 0 - Let’s get set up! — BeeWare 0.3.0 documentation](https://docs.beeware.org/en/latest/tutorial/tutorial-0.html)

python 转 Mac ios android web 项目







```Python
sentence = 'Extract 100 , 100.45 and 10000 from this string'
s = [int(s) for s in str.split(sentence) if s.isdigit()]

# pip install nums_from_string
import nums_from_string
print(nums_from_string.get_nums(sentence))
```

### [Remove Element from an Array in Python](https://stackabuse.com/remove-element-from-an-array-in-python/)

```python
array.remove(40) # l.remove(value)

index = 3
array.pop(index)

del array[index]


```





[luvsound/pippi: computer music with python](https://github.com/luvsound/pippi)
[maxhumber/hickory: 🕰 The command line tool for scheduling Python scripts](https://github.com/maxhumber/hickory)

### **django builder

[Django Builder](https://djangobuilder.io/?#/)
[mmcardle/django_builder: Django Builder Site](https://github.com/mmcardle/django_builder)

快速搭建 Django 项目，真的 NB！

下载下来后：

```shell
pipenv install django==2.2.3
pipenv install django-extensions djangorestframework
ppython manage.py migrate --run-syncdb # 必须加 --run-syncdb 创建数据库
ppython manage.py createsuperuser
ppython manage.py runserver
```

优点：

1.完全不用配置 templates static 等繁琐的东西，只关注项目有哪些 APP，以及 APP 有哪些 models，model 中有哪些字段就好了

2.快速简单，结构标准

有一些缺点：

1.不需要 superuser 就能创建item，后期不知道能不能添加插件解决

2.admin 页面被设置成只读的了



### aioredis

[Beyond the Cache with Python - Redis](https://redislabs.com/blog/beyond-the-cache-with-python/?utm_source=real-python&utm_medium=media-buy&utm_campaign=pycoders_exclusive_august_2020_newsletter)
[aio-libs/aioredis: asyncio (PEP 3156) Redis support](https://github.com/aio-libs/aioredis)

如

```python
import asyncio
import aioredis

async def main():

  redis = await aioredis.create_redis('redis://:foobared@localhost:6379/0', encoding='utf-8')

  await asyncio.gather(
    add_to_queue(redis, 'Possible vocalizations east of Makanda'),
    add_to_queue(redis, 'Sighting near the Columbia River'),
    add_to_queue(redis, 'Chased by a tall hairy creature')
  )

  redis.close()
  await redis.wait_closed()

def add_to_queue(redis, message):
  return redis.rpush('bigfoot:sightings:received', message)

asyncio.run(main())
```



### makesite 快速生成博客

[sunainapai/makesite: Simple, lightweight, and magic-free static site/blog generator for Python coders](https://github.com/sunainapai/makesite)

## Java

### *十种 JVM 内存溢出的情况

[十种 JVM 内存溢出的情况，你碰到过几种？_架构那点事 - SegmentFault 思否](https://segmentfault.com/a/1190000017226359)

### String

[(2条未读通知) 已知String a="a",String b="b",St_360公司笔试题_牛客网](https://www.nowcoder.com/questionTerminal/e1d84672b3044a1095987df761dc5f49)
[(1 条消息) Java 中 String 对象在堆和常量池中的情况及比较_逝不等琴生的博客 - CSDN 博客](https://blog.csdn.net/qq_40563761/article/details/83031715)

### ArrayList LinkedList

\>  原文地址 \[www.itwanger.com\](http://www.itwanger.com/java/2020/09/28/java-array-linked-list.html)

> ![](https://i.loli.net/2020/09/29/YD9vSdktnZsa4U6.png)

> ArrayList 实现了 List 接口，继承了 AbstractList 抽象类，底层是基于数组实现的，并且实现了动态扩容。

> 一旦在添加元素的时候，发现容量用满了 `s == elementData.length`，就按照原来数组的 1.5 倍（`oldCapacity >> 1`）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上 `Arrays.copyOf(elementData, newCapacity)`。

> 比如说，默认的数组大小是 10，当添加第 11 个元素的时候，数组的长度扩容了 1.5 倍，也就是 15，意味着还有 4 个内存空间是闲置的，对吧？
>
> 序列化的时候，如果把整个数组都序列化的话，是不是就多序列化了 4 个内存空间。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。
>
> 于是，ArrayList 做了一个愉快而又聪明的决定，内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。

> 02、LinkedList 是如何实现的？

> ![](https://i.loli.net/2020/09/29/a3pePvxMQYEohli.png)

> LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。

> LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。代码如下所示：

> ```
> private static class Node<E> {
>  E item;
>  LinkedList.Node<E> next;
>  LinkedList.Node<E> prev;
> 
>  Node(LinkedList.Node<E> prev, E element, LinkedList.Node<E> next) {
>      this.item = element;
>      this.next = next;
>      this.prev = prev;
>  }
> }
> ```

> ArrayList 和 LinkedList 在新增元素时究竟谁快？

> 如果是从集合的头部新增元素，ArrayList 花费的时间应该比 LinkedList 多，因为需要对头部以后的元素进行复制。

> 如果是从集合的中间位置新增元素，ArrayList 花费的时间搞不好要比 LinkedList 少，因为 LinkedList 需要遍历。

> 如果是从集合的尾部新增元素，ArrayList 花费的时间应该比 LinkedList 少，因为数组是一段连续的内存空间，也不需要复制数组；而链表需要创建新的对象，前后引用也要重新排列。

> ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有**头部新增元素的时候比 LinkedList 差，因为数组复制的原因**。

> 1）ArrayList

> 从源码可以看得出，只要删除的不是最后一个元素，都需要数组重组。删除的元素位置越靠前，代价就越大。

> LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。

> *   从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；
>     
> *   从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；
>     
> *   从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。
>     

> 结果和新增元素保持一致

> for 循环遍历的时候，ArrayList 花费的时间远小于 LinkedList；迭代器遍历的时候，两者性能差不多。

> 遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器

- ### bootstrap.properties 和 application.properties 有何区别 ?

单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。

bootstrap.properties 在 application.properties 之前加载，配置在应用程序上下文的引导阶段生效。



- ### Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?

**Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 `java -jar xxx.jar` 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类**。

Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 `\BOOT-INF\classes` 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。




- ### Spring Boot 中如何实现定时任务 ?

在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。

使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。

使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。

关于定时任务这一块，大家可以参考：[Spring Boot 中实现定时任务的两种方式!](https://mp.weixin.qq.com/s/_20RYBkjKrB4tdpXI3hBOA)




- ### Spring Boot 如何实现热部署 ?

Spring Boot 实现热部署其实很容易，引入 **devtools** 依赖即可，这样**当编译文件发生变化**时，Spring Boot 就会自动重启。在 Eclipse 中，用户按下保存按键，就会自动编译进而重启 Spring Boot，IDEA 中由于是自动保存的，自动保存时并未编译，所以需要开发者按下 Ctrl+F9 进行编译，编译完成后，项目就自动重启了。

如果仅仅只是**页面模板发生变化**，Java 类并未发生变化，此时可以不用重启 Spring Boot，使用 **LiveReload** 插件就可以轻松实现热部署。



- ### Spring Security 和 Shiro 各自的优缺点 ?

由于 Spring Boot 官方提供了 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口；

Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架





- ### 微服务中如何实现 session 共享 ?

在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 



### 缓存穿透、缓存雪崩、热点数据失效

[关于缓存穿透、缓存雪崩、热点数据失效问题的解决方案！](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247489559&idx=1&sn=80ae90db83d6b19819284f0d342e210f&chksm=fba6f014ccd17902e07dd7b567cd05ef95500dfd4ac499d4be218913494fe30afc05d9ea4814&mpshare=1&scene=24&srcid=0928u7dPOvxn3M0sd0YCSCGm&sharer_sharetime=1601296733328&sharer_shareid=e780165b85dddf2dc106811592851c29#rd)

> #### 缓存穿透

> 如果有黑客会对你的系统进行攻击，拿一个不存在的 id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉

> 2.3 解决办法
>
> 2.3.1 缓存空值

> 2.3.2 BloomFilter

> 2.4 如何选择
>
> 针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。
>
> 针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。

> #### 缓存击穿

> 在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都打到数据库上面去

> 如何解决
>
> 上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。

> #### 缓存雪崩

> 某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到 DB 上面

> 解决办法

> 集群缓存

### springboot + spring cloud 教程

收藏从未停止，学习从未开始。。。

[Spring Boot 2.x基础教程 | 程序猿DD](http://blog.didispace.com/spring-boot-learning-2x/)
[Spring Cloud 从入门到精通 | 程序猿DD](http://blog.didispace.com/spring-cloud-learning/)

### 单例模式

[多线程下单例模式：懒加载（延迟加载）和即时加载 - Monodrama - 博客园](https://www.cnblogs.com/jingpeipei/p/5771716.html)

常见的 3 种实现：

**1**

```java
public class Singleton{
  private static Singleton singleton;
  private Singleton(){}
  public static Singleton getInstace(){
    if (sigleton==null){
      synchronized{
        // double check
        if (singleton==null)
        	singleton = Singleton();
      }
    }
    return sigleton;
  }
}
```

单例+惰性加载

**2**

```java
public class Singleton{
  private Singleton(){}
  private static class SingletonContainer{
    public static Singleton singleton = Singleton();
  }
  public static Singleton getInstance(){
    return SingletonContainer.singleton;
  }
}
```

单例：JVM 的机制保证类加载的过程线程互斥，所以SingletonContainer.singleton 只会被创建一次

惰性加载：SingletonContainer 只有在调用 getInstance 方法才会被加载

### ioc aop

[IoC与AOP的那点事儿 | 程序猿DD](http://blog.didispace.com/spring-ioc-aop/)

**ioc**: inversion of control 控制反转，（对象的控制权）

`IoC`的主要实现方法有两种,`依赖注入`与`依赖查找`.

**依赖注入 :** 应用程序被动的接收对象,`IoC`容器通过类型或名称等信息来判断将不同的对象注入到不同的属性中.

依赖注入主要有以下的方式:

- 基于`set`方法 : 实现特定属性的public set()方法,来让`IoC`容器调用注入所依赖类型的对象.

- 基于接口 : 实现特定接口以供`IoC`容器注入所依赖类型的对象.

- 基于构造函数 : 实现特定参数的构造函数,在创建对象时来让`IoC`容器注入所依赖类型的对象.
- 基于注解 : 通过`Java`的注解机制来让`IoC`容器注入所依赖类型的对象,例如`Spring`框架中的`@Autowired`.

**依赖查找 :** 它相对于`依赖注入`而言是一种更为主动的方法,它会在需要的时候通过调用框架提供的方法来获取对象,获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态.

举例：

```java
public class Person {
	// 由Person自己管理Food类的创建
	public void eat() {
		Food food = new Chicken();
		System.out.println("I am eating " + food.getName() + "...");
	}
}

// use ioc:
public class Person {
	private Food food;

	// 通过set注入
	public void setFood(Food food) {
		this.food = food;
	}

	// Person不需要关注Food,只管使用即可
	public void eat() {
		System.out.println("I am eating " + this.food.getName() + "...");
	}

}
```



aop: aspect oriented programming 面向切面编程

动态地将代码切入到内的指定方法，指定位置上

切面：切入 使用的代码

切入点：切入到哪些类的哪些方法

我们使用`AspectJ`,它是一个`AOP`框架,扩展了Java语言,并定义了`AOP`语法(通过它实现的编译器).

使用`AspectJ`需要先安装并将lib中aspectjrt.jar添加进入classpath,[下载地址](http://www.eclipse.org/aspectj/downloads.php).

```java
public class Something {
    public void say() {
        System.out.println("Say something...");
    }

    public static void main(String[] args) {
        Something something = new Something();
        something.say();
    }
}

public aspect SomethingAspect {
    /**
     * 切入点,切入到Something.say()
     */
    pointcut recordLog():call(* com.sun.sylvanas.application.hello_aop.Something.say(..));

    /**
     * 在方法执行后执行
     */
    after():recordLog() {
        System.out.println("[AFTER] Record log...");
    }
}
```

### 集合

[【两万字】面试官：听说你很懂集合源码，接我二十道问题！ - 掘金](https://juejin.im/post/6844904200611053575#heading-0)

Collection 接口继承 Iterable，Iterable 有spliterator 方法

`Spliterator()`是`1.8`新加的方法，字面意思可分割的迭代器，不同以往的`iterator()`需要顺序迭代，`Spliterator()`可以分割为若干个小的迭代器进行并行操作，既可以实现多线程操作提高效率，又可以避免普通迭代器的`fail-fast`(`fail-fast`机制是`java`集合中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生`fail-fast`事件)机制所带来的异常。`Spliterator()`可以配合`1.8`新加的`Stream()`进行并行流的实现，大大提高处理效率。

Collection() 提供的常用接口方法：size isEmpty contains iterator toArray add remove containsAll addAll removeAll retainAll clear spliterator stream parallelStream

**toArray() 方法的实现**

```java
public Object[] toArray(){
  Object[] r = new Object[size()];
  Iterator<E> it  iterator();
  for (int i=0; i<r.length; i++){
    // 防止因其他线程操作集合，使得集合变小
    if (!it.hasNext())
      // 从 r 中拷贝前 i 个元素返回
      return Arrays.copyOf(r, i);
   	r[i] = it.next();
  }
  // 防止因其他线程操作集合，使得集合变大
  return it.hasNext()?finishToArray(r, it):r;
}
```

Arrays.copyOf(r, i) 调用了 native 方法(借由 c c++ 实现对操作系统底层的访问和操作) :

System.arraycopy(src, srcPos, dest, destPos, length)

**List**

remove(index) remove(obj) indexOf(obj) lastIndexOf(obj) removeAll(UnaryOperator) sort(Comparator)

```java
strl.replaceAll(i -> "p"+i)
l.sort((i, j) -> i.getName().compareTo(j.getName()))
```

**ArrayList**

1、ArrayList(int initCapacity) 可以传入初始容量

2、ArrayList扩容时，capacity = size()*1.5

**map**

map.entrySet() 的排序

利用 Map.Entry.comparingByKey

```java
public class Test {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<String,String>();
        map.put("A","test1");
        map.put("B","test2");
        map.put("E","test5");
        map.put("D","test4");
        map.put("C","test3");
        Stream<Map.Entry<String, String>> sorted = map.entrySet().stream().sorted(Map.Entry.comparingByKey());
        Stream<Map.Entry<String, String>> sorted2 = map.entrySet().stream().sorted(Map.Entry.comparingByKey(String::compareTo));
        sorted.forEach(entry -> System.out.println(entry.getValue()));
        System.out.println("===============");
        sorted2.forEach(entry -> System.out.println(entry.getValue()));
    }
}


```

**HashMap**

数组+链表/红黑树 实现，hash重合的元素少的话用链表，多的话用红黑树



[万字长文，62道Java核心面试题，一次性打包送给积极向上的你 - 掘金](https://juejin.im/post/6850418114333671431#heading-41)

**对自定义对象的集合进行排序**

实现 Comparable 接口，重写 compareTo(obj) 方法



try 块可以没有 catch，直接 try-finally

序列化、反序列化：实现 Serializable 接口，就可以使用 java.io.ObjectOutputStream 将对象写入文件

instanceof: 检查对象是否属于一个类：如 s instanceof String



**下面这段代码，foo() 方法调用了吗？**

```java
public class Test {
    public static String foo(){
        System.out.println("测试 foo 方法有没有被调用");
        return "";
    }

    public static void main(String args[]){
        Test obj = null;
        System.out.println(obj.foo());
    }
}

```

调用了，obj.foo() 会被优化为 foo()

字节码：

```java
public class Test {
    public Test() {
    }

    public static String foo() {
        System.out.println("测试 foo 方法有没有被调用");
        return "";
    }

    public static void main(String[] args) {
        Test obj = null;
        System.out.println(foo());
    }
}

```



### 枚举

[恕我直言，我怀疑你并不会用 Java 枚举](https://mp.weixin.qq.com/s/5QrbbHwo6snBA6gIKPIjPQ)

```java
public enum PlayerType{
  A, B, C
}
```

编译器编译的时候才替换为具体的实现



**内部枚举**

限定外部类中使用

**枚举可用于 switch**

**枚举可以有构造方法**

```java
public enum PlayerType {
    TENNIS("网球"),
    FOOTBALL("足球"),
    BASKETBALL("篮球");

    private String name;

    PlayerType(String name) {
        this.name = name;
    }
}
```



EnumSet EnumMap

**枚举实现单例**

通常情况下：

```java
public class Singleton{
  private volatile static Singleton singleton;
  private Singleton (){}
  public static Singleton getSingleton(){
    if(singleton==null){
      synchronized(Singleton.class){
        if (singleton==null)
          singleton = new Singleton();
      }
    }
    retuurn singleton;
  }
}
```

枚举实现单例：

```java
public enum EasySingleton{
  INSTANCE;
}
```

没看懂

枚举可与数据库交互

没看懂

### screw 一键生成数据库文档

[一键生成数据库文档，堪称数据库界的Swagger，有点厉害 - 掘金](https://juejin.im/post/6865485568038404103)

### check if a class exist in java

```java
@Test
public void givenInitializingClass_whenUsingForNameWithoutInitialization_thenNoException() throws ClassNotFoundException {
   //2句注释等同
   //Class.forName("path.to.InitializingClass");
   //Class.forName("path.to.InitializingClass", true, getClass().getClassLoader());
  // false 表示不调用初始代码块，以节省资源
    Class.forName("path.to.InitializingClass", false, getClass().getClassLoader());
}
```



### stream < -- >array

```java
Arrays.stream(array)
Stream.of(array)

stream.toArray()

```

### [Remove Element from an Array in Java](https://stackabuse.com/remove-element-from-an-array-in-java/)

```java
// 1.using 2 arrays
for (int i = 0, j = 0; i < array.length; i++) {
	if (i != index) {
		copy[j++] = array[i];
	}
}
// 2. ArrayUtils.remove()
// Before working with Apache Commons, we'll want to add it to our project:
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>${version}</version>
</dependency>

array = ArrayUtils.remove(array, index);

// 3.using a for loop
for (int i = index; i < array.length - 1; i++) {
	array[i] = array[i + 1];
}

// 4. System.arraycopy
// public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
System.arraycopy(array, index+1, array, index, array.length-index-1)
```



### **论坛经验

研二上 9-12月
三个月零碎的时间刷题，建议可以跟下bt极客时间覃超的算法课，系统学习后再刷，开始时间可以尽量早，当时我抛开算法课的题目刷了100左右，以medium为主

实习准备：12-4月末
12-3
保持每天关注牛客+论坛的内推信息；
保持每天的刷题，剑指offer+leetcode每日一题+面试题实战，到4月底为止leetcode250+，剑指offer大部分刷透；
制定计划学习/复习面试基础（github：cyc，bilibili：talkdata），同时做自己的笔记补充上面不够完整的地方；
准备简历，思考自己的技能点和项目难/亮点（实验室项目不相关，用了本科毕设增强版+小公司实习的一个项目）；
每天有效学习时长大概8-10个小时；

3-4
关注牛客的面经，查缺补漏；
关注各个大厂的提前批（**提前批非常重要！！！**），提前加vx联系bu的面试官，了解bu的hc和工作内容；
各个公司笔试+面试，面试后的记录与复盘，查缺补漏，完善知识体系；

4-6
面试数量逐渐减少，实习offer逐渐到手
没啥大事可以放松一下节奏，准备实习

6-9
蚂蚁实习+实验室项目；
腾讯提前批；
字节秋招直通终面；
实习+实验室强度大，没有再刷题了；
\------------------------------------------------------------------------
接下来整理一下后端研发面试内容和推荐的学习方法（懒的自己整理的同学我直接建议去B站找talkdata买一套他的java知识点总结，书籍划重点在博客中也有推荐，确实良心）：
\1. Java基础：Object方法、重载重写、String常量池、equals、final/static，最重要的是HashMap等容器的底层源码实现，推荐书籍《Java编程思想》
\2. JVM：JVM的内存区域、垃圾回收算法、垃圾收集器、GC内存分配/GC调优、类加载与双亲委派，推荐书籍《深入理解Java虚拟机》；
\3. Java并发：线程生命周期、volatile、synchronized、ConcurrentHashMap、CAS、AQS、线程池等，推荐书籍《Java高并发程序设计》、《Java并发编程的艺术》二选一，我看的前面的；
\4. Mysql：ACID、隔离级别、B+ Tree、InnoDB/MyISAM、聚集/非聚集索引、主从复制等，推荐书籍《mysql必知必会》、《高性能MySQL》；
\5. Redis：面试问的频率较低，可选，Redis性能高的原因、5种数据类型、过期策略和缓存淘汰机制、持久化机制、主从复制、缓存雪崩等，推荐书籍《Redis设计与实现》；
\6. 计算机网络：网络分层、TCP/UDP区别、TCP头部结构、三次握手四次分手、TCP可靠性保证手段、DNS、HTTP/HTTPS、Cookie/Session、浏览器输入网址后发生的事情等，推荐书籍《图解TCP/IP协议》，没时间不看，根据知识点去知乎、csdn等自己补全；
\7. 操作系统：进程、线程、进程通信方式、内存管理、IO管理等，不推荐书籍，自己根据面试点补全；
\8. Linux：inode/block、僵尸进程/孤儿进程、常用指令（top、more/less、ps、netstat、lsof、cat、rm等），不推荐书籍，去看博客；
\9. 设计模式：六大原则、单例模式（懒汉/饿汉）能手写、工厂模式、其他模式结合项目理解，推荐书籍《大话设计模式》
\10. Spring：SpringIOC、SpringAOP、bean、Spring事务，会不会不是特别重要，我项目都是Spark/Hive啥的，Spring是进公司学的，但是如果本身项目就是Spring，那么一定要准备充分，推荐书籍《Spring技术内幕》、小马哥讲Spring视频等
\11. 可选加分-大数据：MapReduce/YARN/HDFS/Spark等大数据框架
\12. 可选加分-分布式-Zookeeper：ACID、CAP、BASE理论、2PC/3PC/Paxos/ZAB/raft、Zookeeper系统模型、Leader选举等，推荐书籍《从Paxos到Zookeeper分布式一致性协议》
\------------------------------------------------------------------------
笔试流程：
现在内推不给面笔试了，所以笔试还是比较重要的，通常时间是两个点，5道题左右，a出2.5以上都有面试机会，难度不会特别大，medium左右的情景题，腾讯没参加过，字节、美团、快手、网易笔试都差不多，阿里恶心人两道hard一个小时，面过后低分要补笔试，难度正常

\------------------------------------------------------------------------

面试流程：
通常是一个小时的面试，也不排除2个小时的超长面；
首先介绍自己，聊简历项目和难点攻克；15~30min
基础问答，一般是java，计网，数据库相关；20~30min
做题，基本是剑指offer的原题，所以剑指一定刷透，或者是情景设计题，让你设计解决方案，如腾讯25马选最快5马问题等；10~15min
所以面试基础问的比例还是不是特别高，答得准确答得深入是加分的关键；
实习面经：http://note.youdao.com/s/cWe9G6L0
实习后的没有整理![ema3](https://i.loli.net/2020/09/14/AJG3Wp1E52YRP8j.gif)
\------------------------------------------------------------------------
公司和方向推荐：
对于Java同学，可以做大多数的服务端开发，包括使用Golang（进去后培训转语言），同时也可以选择大数据方向，需要关注的重点是自己的兴趣、公司与行业领域的发展；
自己实习收获了蚂蚁、字节、美团、网易的offer，秋招收获了蚂蚁、字节、腾讯的offer，结合自己之后应该不会留在一线城市（买不起房，相对考虑杭州南京重庆成都等二线），从面试感受、工作地点、工作强度、内容与待遇上，比较推荐蚂蚁、字节和网易（阿里杭州10w真香），借呗这边团队995，周三周五6点下班，网易差不多，字节大小周，可以参考下。

### **java 学习路线

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b9c99dbd71a43919fcbd28a55cd4942~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%;" />

### springboot 首页

[SpringBoot - 设置项目默认的首页（欢迎页）](https://www.hangge.com/blog/cache/detail_2528.html)

\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[www.hangge.com\](https://www.hangge.com/blog/cache/detail\_2528.html)

  Spring Boot 项目启动后，默认会去查找 index.html 文件作为首页面。当然我们可以指定其它页面作为首页面，下面通过样例进行演示。

[![](https://www.hangge.com/blog_uploads/201907/2019072515395624442.png)](#)

#### 一、使用 index.html 作为首页面

1，静态首页

Spring Boot 项目在启动后，首先回去静态资源路径（resources/static）下查找 index.html 作为首页文件。

[![](https://i.loli.net/2020/09/13/uNxfFjWasgBb7Qc.png)](#)

2，动态首页

    如果在静态资源路径（resources/static）下找不到 index.html，则会到 resources/templates 目录下找 index.html（使用 Thymeleaf 模版）作为首页文件。

[![](https://www.hangge.com/blog_uploads/201907/201907251427098973.png)](#)

#### 二、使用非 index.html 的文件作为首页面

1，静态首页

（1）假设我们在 resources/static 目录下有个 login.html 文件，想让它作为首页。

[![](https://i.loli.net/2020/09/13/pDUg148rbujVLPo.png)](#)

（2）一种方式通过自定义一个 Controller 来进行转发：

```java
@Controller

public class HelloController {

    @RequestMapping("/")

    public String hello(){

        return "forward:login.html";

    }

}
```

（3）另一种方式是通过自定义一个 MVC 配置，并重写 addViewControllers 方法进行转发：

```java
@Configuration

public class WebMvcConfig implements WebMvcConfigurer {

    @Override

    public void addViewControllers(ViewControllerRegistry registry) {

        registry.addViewController("/").setViewName("forward:login.html");

    }

}
```

#### 动态首页

（1）假设我们在 resources/templates 目录下有个 login.html 文件（使用 Thymeleaf 模版），想让它作为首页。

[![](https://i.loli.net/2020/09/13/yVeoA4QDscdHWYT.png)](#)

（2）一种方式通过自定义一个 Controller 来实现，在 Controller 中返回逻辑视图名即可：

```java
@Controller

public class HelloController {

     @RequestMapping("/")

     public String hello(){

         return "login";

     }

}
```

（3）另一种方式是通过自定义一个 MVC 配置，并重写 addViewControllers 方法进行映射关系配置即可。

```java
@Configuration

public class WebMvcConfig implements WebMvcConfigurer {

    @Override

    public void addViewControllers(ViewControllerRegistry registry) {

        registry.addViewController("/").setViewName("login");

    }

}
```

### *自动更新项目

**1.静态资源改变时，自动刷新浏览器**

1.1 liveReload 插件安装

[Chrome 网上应用店 - LiveReload](https://chrome.google.com/webstore/search/LiveReload)

1.2 pom 依赖添加

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

参考：[Spring Boot 修改静态资源一定要重启项目才会生效吗？未必！ - 江南一点雨](http://www.javaboy.org/2019/0808/springboot-livereload.html)

**2.IDEA SpringBoot 热部署+html修改无需make自动刷新**

[IDEA SpringBoot 热部署+html修改无需make自动刷新_cencfeng11的博客-CSDN博客](https://blog.csdn.net/cencfeng11/article/details/79374934)



### *centos quick Install `jdk`, `git`, `maven`, `redis`, `mysql`

```shell
wget -O download-install-all.sh https://springboot.plus/bin/download-install-all.sh
sh download-install-all.sh
```

### mybatis-generator-gui 快速生成Mybatis的Java POJO文件及数据库Mapping文件

[zouzg/mybatis-generator-gui: mybatis-generator界面工具，让你生成代码更简单更快捷](https://github.com/zouzg/mybatis-generator-gui)

![image-20200912133029123](https://i.loli.net/2020/09/12/ldh5P9cH2NEZ4WV.png)



生成的文件目录：

感觉很简陋，辅助用的

![image-20200912133114953](https://i.loli.net/2020/09/12/HDj1vKrBPwmLN85.png)



### SpringBoot启动服务的三种方式

[SpringBoot启动服务的三种方式_执-CSDN博客](https://blog.csdn.net/zane3/article/details/73729717)

> mvn spring-boot:run

> mvn install
> 之后跳转到当前项目的 target 文件夹下
> java -jar 项目的 jar 名

## go

[swaggos首页、文档和下载 - swagger 文档生成器 - OSCHINA - 中文开源技术交流社区](https://www.oschina.net/p/swaggos)

## cli

## 数据库 Redis



[Chrome MySQL Admin](https://www.eisbahn.jp/chrome_mysql_admin/)

### ElectroCRUD

全平台

[ElectroCRUD 2 (beta) | Simple solution to manage your database that not involves writing code or installs web-based solutions.](https://garrylachman.github.io/ElectroCRUD/)



[Redis(8)——发布/订阅与Stream - 我没有三颗心脏 - 博客园](https://www.cnblogs.com/wmyskxz/p/12499532.html)

stream 是 pubsub 的替代，有 ACK 和 持久化

[Reids(4)——神奇的HyperLoglog解决统计问题 - 我没有三颗心脏的博客](https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/)

hyperloglog 是估算基数的近似最优算法

基数特别大的话，就算每个比特存储一个数据（bitmap），统计一亿个数据的基数需要 12M

而 Redis 中实现的 hyperloglog 只需 12K（不过是近似的，误差在 5%左右）

Redis 做了很多优化，比如 多个 hyperloglog 去除异常值后取平均，以降低误差

### Guava 中自带的布隆过滤器

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>28.0-jre</version>
</dependency>
```



```java
// 创建布隆过滤器对象
BloomFilter<Integer> filter = BloomFilter.create(
        Funnels.integerFunnel(),
        1500,
        0.01);
// 判断指定元素是否存在
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
// 将元素添加进布隆过滤器
filter.put(1);
filter.put(2);
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
```





## git

[GitUp](https://gitup.co/)

[Free Git GUI Client - Windows, Mac, Linux | GitKraken](https://www.gitkraken.com/)

## shell

### vim

[编辑神器Vim新教程出炉，GitHub 3400星，复杂命令轻松搞定](https://mp.weixin.qq.com/s/iDK_jvCINbSHK14drPRVwQ)
[wsdjeg/Learn-Vim_zh_cn](https://github.com/wsdjeg/Learn-Vim_zh_cn)

:set number  显示行号

:syntax on 打开语法高亮

j ↓

k ↑

h ←

l →

w 下一个词

b 上一个词

0 行首

$ 行尾

gg 第一行

G 最后一行

{ | } 空行之间快速跳转

line number + gg 快速跳转到那一行



vim +20 class.js 用 vim 打开 class.js 并跳转到 20 行



u  undo

r  redo



d 删除(，并保存到寄存器)

y 复制

d\y 重复使用表示对当前行操作





dd 删除 1 行

yy 复制 1 行

dd yy 前可以加数字，表示删除、复制 n 行

4dd  删除 4 行

3yy 复制 3 行



d y 后面可以添加 w b  0 $ G gg 进行组合

dw 删除 1 个 Word

dG 删除到文章结尾

d0 删除到行首

d$ 删除到行尾



p 粘贴（可以将 d 删除的粘贴过来）



[Learn-Vim_zh_cn/ch12_search_and_substitute.md at master · wsdjeg/Learn-Vim_zh_cn](https://github.com/wsdjeg/Learn-Vim_zh_cn/blob/master/ch12_search_and_substitute.md)

在您的vimrc中，添加:

```
set ignorecase smartcase
```

/fianl   enter 搜索         n next N previous

/^hello 出现在开头(试了下，空格在前面也不行)

/hello$ 出现在结尾

用 // 重复上一次的搜索



:%s/live/life/gc  搜索并替换  c 表示每次替换都问用户是否替换，否则直接替换所有



## 前端

### **HTTP

#### 不同 HTTP 版本与请求方法的添加

0.9 get

1.0 post head  (head: 查询 URI 的有效性或资源更新时间)

1.1 put delete (put: 传送文件)

2.0 options (options: 某些时候跨域前会发送 options 请求，查询资源支持的请求方法。。。)



#### options

[什么时候会发送options请求 - 掘金](https://juejin.im/post/6844903821634699277)

有的人说：跨域并写了自定义请求头就会发OPTIONS

options 的 request header 的关键字段：

access-control-request-method: 告诉服务器实际请求的 HTTP 方法

access-control-request-headers: 告诉服务器实际请求头部哪些字段是自定义的

options 的 response header 的关键字段：

Access-Control-Allow-Methods 服务端允许的一些请求

Access-Control-Allow-Credentials 允许跨域携带cookie（**跨域请求要携带cookie必须设置为true**）  

Access-Control-Allow-Origin 允许跨域请求的域名，这个可以在服务端配置一些信任的域名白名单  

Access-Control-Request-Headers 客户端请求所携带的自定义首部字段content-type

**url uri urn**

[http - What is the difference between URI, URL and URN? - Stack Overflow](https://stackoverflow.com/questions/4913343/what-is-the-difference-between-uri-url-and-urn/26410882#26410882)

url: uniform resource locator

uri: uniform resource identifier

urn: uniform resource name

difference:

![enter image description here](https://i.loli.net/2020/09/16/AqoxlTaVbsXEK26.jpg)

![enter image description here](https://i.loli.net/2020/09/16/6LhnENMmbOK98fU.jpg)

#### 重定向 和 转发

[重定向和请求转发的区别 - 知乎](https://zhuanlan.zhihu.com/p/40114605)

重定向：返回 302，headers 中 设置 Location 用于给浏览器标识重定向的地址，浏览器发起二次请求

转发：服务器完成二次请求（因此转发快一点）

重定向地址栏的 URL 会发生变化；转发则不会

我们知道在Java Web中，一个Servlet分别是这么写重定向和转发的代码的：

1、response.sendRedirect("XXX");

2、request.getRequestDispatcher("XXX").forward(request, response);



#### 缓存

[深入剖析浏览器缓存策略 - 掘金](https://juejin.im/post/6844903812600184845#heading-1)
[彻底弄懂HTTP缓存机制及原理 - 云中桥 - 博客园](https://www.cnblogs.com/chenqf/p/6386163.html)
[深入理解HTTP缓存机制及原理 - 掘金](https://juejin.im/post/6844903801778864136#heading-5)

**Cache-Control** 可以设置 private public max-age no-chche

private 该资源只能被浏览器缓存

public 该资源能被浏览器缓存，也能被中间人（如 cdn 代理服务器）缓存

max-age 若 max-age=0 资源仍被缓存，只不过立马过期

no-cache 相当于 max-age=0

no-store 服务器禁止浏览器，中间人缓存该资源

**Expires** 标识缓存具体的过期时间



Cache-Control 和 Exprires 的优先级

同时使用二者的话，Cache-Control 生效



**缓存分类**

强缓存、弱缓存（协商缓存）

不同点在于，强缓存不发送请求到服务器，而 弱缓存会发送请求到服务器以验证资源是否过期。

**若缓存未过期，服务器返回 304** 

普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存。

Header 中的验证标识字段主要有两组：`Etag` 和 `If-None-Match` 、`Last-Modified` 和 `If-Modified-Since` 。其中，形如 `If-xxx` 这样的请求首部字段，可以称之为条件请求。比如只在满足某个条件的情况下返回或上传文件，这样可以节省带宽。

![image-20200916191155369](https://i.loli.net/2020/09/16/rEejACHsdwOPLDq.png)



![img](https://i.loli.net/2020/09/16/OhzCe7dV2SXwmuo.png)

### npm desktop manager

[npm desktop manager](https://720kb.github.io/ndm/)

### referrer和Referrer-Policy

[HTTP请求中的referrer和Referrer-Policy - 掘金](https://juejin.im/post/6844903842484600846)

\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[juejin.im\](https://juejin.im/post/6844903842484600846)

> 当你发起一个 http 请求，请求头中的`referrer`字段就说明了你是从哪个页面发起该请求的

> 有时候我们需要控制这个`referrer`字段的值，即是否让其显示在请求头中，或者是否显示完整路径等

> ### 隐私
>
> 在社交网站的个人中心页面，也许会存在一些外链，这时候社交网站肯定不希望用户在点击这些链接跳转到其他第三方网站时会将自己个人中心的 URL 信息显示在`referrer`字段中传过去，尤其是个人中心页面的 URL 往往会带着用户数据和一些敏感信息。这时候可以选择不显示来源页面 URL 信息或者只显示一个网站根地址 hostname。

> ### 安全
>
> 有些使用了 https 的网站，可能在 URL 中使用一个参数（sid）来作为用户身份凭证，而又需要引入其他 https 网站的资源，这种情况，网站肯定不希望泄露用户的身份凭证信息。当 https 网站需要引入不安全的 http 网站的资源或者有链接要跳转到 http 网站时，这时候将 https 源网站的 URL 信息传过去也是不太安全的。

> `Referrer-Policy`的作用就是为了控制请求头中`referrer`的内容

> ### 空字符串
>
> 若设为空串则默认按照浏览器的机制设置`referrer`的内容，默认情况下是和`no-referrer-when-downgrade`设置得一样

> ### no-referrer
>
> 不显示`referrer`的任何信息在请求头中

> ### no-referrer-when-downgrade
>
> 这是默认值。当从 https 网站跳转到 http 网站或者请求其资源时（安全降级 HTTPS→HTTP），不显示`referrer`的信息，其他情况（安全同级 HTTPS→HTTPS，或者 HTTP→HTTP）则在`referrer`中显示完整的源网站的 URL 信息。

> ### same-origin
>
> 表示浏览器只会显示`referrer`信息给同源网站，并且是完整的 URL 信息。所谓同源网站，是协议、域名、端口都相同的网站。

> ### origin
>
> 表示浏览器在`referrer`字段中只显示源网站的源地址（即协议、域名、端口），而不包括完整的路径。

> ### strict-origin
>
> 该策略更为安全些，和`origin`策略相似，只是不允许`referrer`信息显示在从 https 网站到 http 网站的请求中（安全降级）。

> ### origin-when-cross-origin
>
> 当发请求给同源网站时，浏览器会在`referrer`中显示完整的 URL 信息，发个非同源网站时，则只显示源地址（协议、域名、端口）

> ### strict-origin-when-cross-origin
>
> 和`origin-when-cross-origin`相似，只是不允许`referrer`信息显示在从 https 网站到 http 网站的请求中（安全降级）。

> ### unsaft-url
>
> 浏览器总是会将完整的 URL 信息显示在`referrer`字段中，无论请求发给任何网站。

> Referrer-Policy 更改方法
> --------------------
>
> 可以有以下 5 种方法：

> 总结
> --
>
> 使用何种`Referrer Policy`取决于网站的需求，但是一般来说，`unsafe-url`是不太建议用的，同样，如果是只想显示网站的根地址，那么建议用`strict-origin`和 s`trict-origin-when-cross-origin`。如果 URL 中没有什么敏感信息，那就默认使用`no-referrer-when-downgrade`。

### **amis admin

![image-20200913173936180](https://i.loli.net/2020/09/13/RZlyHTx42ftCNP9.png)

## 后端

### c++ 测试 catch

[c++ TEST_CASE ( 怎么使用 - Google 搜索](https://www.google.com/search?q=c%2B%2B+TEST_CASE(+%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8&oq=c%2B%2B+TEST_CASE(+%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8&aqs=chrome..69i57.9620j0j7&sourceid=chrome&ie=UTF-8)
[C++测试框架Catch - Chen Yuan's Blog](http://dasheyuan.com/post/cpp-test-framework-catch/)
[C++ 的单元测试工具 —— Catch | 时习之](http://blog.guorongfei.com/2016/08/22/cpp-unit-test-catch/)
[c++ - 使用 Catch C++ 进行单元测试会干扰我的 main () - IT 工具网](https://www.coder.work/article/585838)
[as if! | translate to Mandarin Chinese: Cambridge Dictionary](https://dictionary.cambridge.org/dictionary/english-chinese-simplified/as-if?q=as%2Bif)



[Java版阿里云通信短信发送API接口实例（新）_沉默王二-CSDN博客](https://qingmiaogu.blog.csdn.net/article/details/78751698)
[JavaMail](https://javaee.github.io/javamail/)
[GitHub OAuth 第三方登录示例教程 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2019/04/github-oauth.html)
[产品介绍 - 支付宝开放平台](https://opendocs.alipay.com/open/270)
[Wechat-Group/WxJava: WxJava （微信开发 Java SDK），支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的后端开发](https://github.com/Wechat-Group/WxJava)

### https 抓包

ios 好抓，Android 放弃

[在 iOS 和 iPadOS 中信任手动安装的证书描述文件 - Apple 支持](https://support.apple.com/zh-cn/HT204477)



### **nginx

在线无脑快速配置

[NGINX Config | DigitalOcean](https://www.digitalocean.com/community/tools/nginx)

[NGINX Config | DigitalOcean](https://www.digitalocean.com/community/tools/nginx?domains.0.server.domain=search.zronghui.com&domains.0.https.https=false&domains.0.php.php=false&domains.0.reverseProxy.reverseProxy=true&domains.0.reverseProxy.proxyPass=http%3A%2F%2F127.0.0.1%3A8033&domains.0.routing.root=false&domains.0.routing.index=index.html&domains.0.logging.accessLog=true&domains.0.logging.errorLog=true&domains.1.server.domain=test.zronghui.com&domains.1.https.https=false&domains.1.php.php=false&domains.1.reverseProxy.reverseProxy=true&domains.1.reverseProxy.proxyPass=http%3A%2F%2F127.0.0.1%3A8051&global.security.referrerPolicy=no-referrer&global.security.limitReq=true&global.reverseProxy.proxyConnectTimeout=10&global.reverseProxy.proxySendTimeout=10&global.reverseProxy.proxyReadTimeout=10&global.logging.logNotFound=true)

阿里云如果也没有备案的话，会失败

- 如果您没有提交过备案，直接将域名解析至阿里云中国内地（大陆）服务器上，将被阿里云监测系统识别并阻断网站服务，提示您需先完成备案。

#### 安装

```shell
apt-get install nginx
apt autoremove
```

![image-20200914191429952](https://i.loli.net/2020/09/14/rU7NY9uC1QRoqdy.png)





学习：

[尚硅谷Nginx教程(nginx快速上手)_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://www.bilibili.com/video/av68136734?p=14)
[Nginx笔记 | Bwqueen的博客](https://nishigouzi.github.io/2020/06/07/Nginx%E7%AC%94%E8%AE%B0/#more)

#### **反向代理**

1.**设置多个域名对应多个服务**理论上是最方便的，可是阿里不同意。

1.1修改本地 host

101.200.240.225 search.zronghui.com

1.2 nginx 配置

```
server{
    server_name search.zronghui.com;
    
    location / {
        proxy_pass http://127.0.0.1:8033;
    }
}

server{
    server_name anotherServer.zronghui.com;
    
    location / {
        proxy_pass http://127.0.0.1:8034;
    }
}
```



2.**设置多个路径对应多个服务**，如 101.200.240.225/search -> 101.200.240.225:8033

nginx 配置

```
server {
    server_name 101.200.240.225;
    
    location /search {
        proxy_pass http:127.0.0.1:8083;
    }

		location /anotherService {
        proxy_pass http:127.0.0.1:8084;
    }
}
```



**location 规则 **
语法：

<img src="https://i.loli.net/2020/09/15/oL7qlTb6NO4sVYe.png" alt="image-20200915194716264" style="zoom:50%;" />





但是这样导致一些问题，如 101.200.240.225/search 的请求会转发到 101.200.240.225:8033/search

**动静分离**

而且静态文件直接访问的 101.200.240.225/static... ，自然找不到，报 404

[Django 静态文件处理 - 后端 - 掘金](https://juejin.im/entry/6844903587470917646)

cd /etc/nginx

vim nginxconfig.io/general.conf

添加以下配置：(这就算是动静分离了？)

```
location /static/ {
    add_header Cache-Control public;
    alias /root/code/zronghui_xxxt/SearchWeb/static/;
}
```

#### **负载均衡**

![img](https://i.loli.net/2020/09/15/brfloCPSd5wIsMK.png)



**负载均衡的策略：**

轮询(default)

weight

IP hash

fair：按后端服务器响应时间分配请求，响应时间短的优先分配

url_hash: 一个 URL 分配一个服务器，提升后端缓存服务器的效率

#### Nginx 高可用集群

![img](https://i.loli.net/2020/09/15/V8eNCnX2qkQZK3d.png)

1.多个 nginx，都安装 Keepalived

```shell
yum install keepalived
rpm -q -a keepalived # 查看是否安装上
# 配置文件 /etc/keepalived/keepalived.conf
```

2.keepalived.conf

```nginx
global_defs {
	notification_email {
	  acassen@firewall.loc
	  failover@firewall.loc
	  sysadmin@firewall.loc
	}
	notification_email_from Alexandre.Cassen@firewall.loc
	smtp_ server 192.168.17.129
	smtp_connect_timeout 30
	router_id LVS_DEVEL	# LVS_DEVEL这字段在/etc/hosts文件中看；通过它访问到主机
}

vrrp_script chk_http_ port {
	script "/usr/local/src/nginx_check.sh" # 对应↓的脚本
	interval 2   # (检测脚本执行的间隔)2s
	weight 2  #权重，如果这个脚本检测为真，服务器权重+2
}

vrrp_instance VI_1 {
	state BACKUP   # 备份服务器上将MASTER 改为BACKUP
	interface ens33 //网卡名称
	virtual_router_id 51 # 主、备机的virtual_router_id必须相同
	priority 100   #主、备机取不同的优先级，主机值较大，备份机值较小
	advert_int 1	#每隔1s发送一次心跳
	authentication {	# 校验方式， 类型是密码，密码1111
        auth type PASS
        auth pass 1111
    }
	virtual_ipaddress { # 虛拟ip
		192.168.17.50 // VRRP H虛拟ip地址
	}
}
```

3./usr/local/src 新建检测脚本 nginx_check.sh

```shell
#! /bin/bash
A=`ps -C nginx -no-header | wc - 1`
if [ $A -eq 0];then
	/usr/local/nginx/sbin/nginx
	sleep 2
	if [`ps -C nginx --no-header| wc -1` -eq 0 ];then
		killall keepalived
	fi
fi
```

4.启动 nginx 和 keepalived

```shell
systemctl start keepalived.service
ps -ef |  grep keepalived
```



#### nginx 原理解析

![img](https://i.loli.net/2020/09/15/J1lp8zk36WSLsNg.png)

![img](https://i.loli.net/2020/09/15/CtQP9Bgzn3yiOxe.png)

worker 的数量建议与 CPU 保持一致

##### work_connection

一个请求占用 worker 的 2 个或者 4 个连接。(静态资源 2 个 动态资源 4 个； 因为 http1.1 每次访问占用 2 个连接。而动态资源需要反向代理 2*2 = 4）

nginx 能建立的最大连接数 t = worker_processes*worker_connections (worker 进程的数量 x 每个 worker 进程支持的最大连接数)

最大并发数： 静态资源 t/2 ; 反向代理动态资源 t/4

#### 卸载

```shell
# 1. If you want to keep config files
sudo apt-get remove nginx nginx-common
# 2. If you want to uninstall completely
sudo apt-get purge nginx nginx-common

# Check the Status and version
sudo service nginx status
nginx -v
# First Stop nginx service
sudo service nginx stop
# Removes all but config files.
sudo apt-get remove nginx nginx-common
# Removes everything.
sudo apt-get autoremove
# Remove dependencies used by nginx which are no longer required.
sudo service nginx status
```

~~卸载后再安装就一直失败。。。~~ 原来是/etc/config  被我删了，官网下载安装包，把里面的 config 复制过去就好了



#### [Nginx面试题（总结最全面的面试题！！！） - 掘金](https://juejin.im/post/6844904125784653837)



**nginx.conf 有哪些属性模块**

```
worker_processes  1；                			# worker进程的数量
events {                              			# 事件区块开始
    worker_connections  1024；          		# 每个worker进程支持的最大连接数
}                               			# 事件区块结束
http {                           			# HTTP区块开始
    include       mime.types；         			# Nginx支持的媒体类型库文件
    default_type  application/octet-stream；            # 默认的媒体类型
    sendfile        on；       				# 开启高效传输模式
    keepalive_timeout  65；       			# 连接超时
    server {            		                # 第一个Server区块开始，表示一个独立的虚拟主机站点
        listen       80；      			        # 提供服务的端口，默认80
        server_name  localhost；    			# 提供服务的域名主机名
        location / {            	        	# 第一个location区块开始
            root   html；       			# 站点的根目录，相当于Nginx的安装目录
            index  index.html index.htm；       	# 默认的首页文件，多个用空格分开
        }          				        # 第一个location区块结果
        error_page   500502503504  /50x.html；          # 出现对应的http状态码时，使用50x.html回应客户
        location = /50x.html {          	        # location区块开始，访问50x.html
            root   html；      		      	        # 指定对应的站点目录为html
        }
    }  
    ......

```





**怎么用 NGINX 解决前端跨域问题？**

跨域是浏览器的问题，不是服务器的问题，只是浏览器对服务器发回的请求做了限制/拦截

- 使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将 NGINX 将这些接口转发到真正的请求地址。



**Nginx 设置 IP 不可访问**

```shell
if($remote_addr = 192.168.9.115){
    return 403;
}
```



**怎么限制浏览器访问**

```shell
if ($remote_addr ~ Chrome){
    return 500;
}
```



**限流**

限制访问频率

1r/s代表1秒一个请求，1r/m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求  

突发限制访问频率

Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求

限制并发连接数

配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接



**漏桶算法、令牌桶算法**

漏桶算法：突发流量进入一个漏桶，漏桶按照固定速率处理请求，如果水流过大会溢出（请求被拒绝）。

令牌桶算法：令牌桶按照固定速率产生令牌，若请求到达时令牌用完了，请求被拒绝。若令牌产生的速度大于消耗的速度，令牌会一直产生，直至装满整个令牌桶。

[架构师的初级技能，选组件！（2020更新版） - 掘金](https://juejin.im/post/6870288195674718222)

还附有一系列文章

### **job 将命令行规划成任务

注意若 job s ./dailyreport.sh

sh 文件需以 #!/usr/bin/env bash 开头，否则 failed: repeat 0 failed: fork/exec /root/dailyreport.sh: exec format error

[liujianping/job: JOB, make your short-term command as a long-term job. 将命令行规划成任务的工具](https://github.com/liujianping/job)

```shell
$: job -h
Job, make your short-term command as a long-term job

Usage:
  job [flags] [command args ...]

Examples:

	(simple)      $: job echo hello
	(schedule)    $: job -s "* * * * *" -- echo hello
	(retry)       $: job -r 3 -- echox hello
	(repeat)      $: job -n 10 -i 100ms -- echo hello
	(concurrent)  $: job -c 10 -n 10 -- echo hello
	(timeout cmd) $: job -t 500ms -- sleep 1
	(timeout job) $: job -T 3s -r 4 -- sleep 1

Flags:
  -t, --cmd-timeout duration       job command timeout duration
  -c, --concurrent int             job concurrent numbers
  -h, --help                       help for job
  -T, --job-timeout duration       job timeout duration
  -i, --repeat-interval duration   job repeat interval duration
  -n, --repeat-times int           job repeat times, 0 means forever (default 1)
  -r, --retry int                  job command retry times when failed
  -s, --schedule string            job schedule in crontab format
      --version                    version for job
```



[The Log File Navigator](http://lnav.org/)

### TarsBenchmark

[TarsBenchmark首页、文档和下载 - 无码压测工具 - OSCHINA - 中文开源技术交流社区](https://www.oschina.net/p/tarsbenchmark)

### minify 

最小化 html css js 等文件 有 web 、cli、go

[tdewolff/minify: Go minifiers for web formats](https://github.com/tdewolff/minify)

### webify 将 shell 命令一行改为 web 服务

[beefsack/webify: Turn shell commands into web services](https://github.com/beefsack/webify)

```shell
# Make a web service out of `wc` to count the characters in the request body.
$ webify wc -c
2020/08/25 12:42:32 listening on :8080, proxying to wc -c

...

$ curl -d 'This is a really long sentence' http://localhost:8080
30
```



### takeout

[tighten/takeout: Docker-based development-only dependency manager; pairs with Valet.](https://github.com/tighten/takeout)

mac 快速配置 mysql elasticsearch redis mongo 等服务



### docker_mirror: 查找最快的docker镜像

[silenceshell/docker_mirror: 查找最快的docker镜像](https://github.com/silenceshell/docker_mirror)

## 项目

[Awesome Repos](https://aggregatedawesome.com/)

## 其他

# 玩机

## Chrome

### **GitHub加速

[GitHub加速 - Chrome 网上应用店](https://chrome.google.com/webstore/detail/github%E5%8A%A0%E9%80%9F/mfnkflidjnladnkldfonnaicljppahpg/related)

## Mac

### pdf editor 导出的笔记转成 Markdown

用 cot editor 打开文本

导出批注为 文本，然后进行替换

下划线 \[前往页面 \d+]:   -->   空

^(\d+.)    -->   ### $1





[Menu Bar Dock](https://www.etggames.com/menu-bar-dock)



[苹果软件合集之开发者工具（一） - 掘金](https://juejin.im/post/6865912845414957063)
[苹果软件合集之开发者工具（二） - 掘金](https://juejin.im/post/6865912972158435336)

### you-get 下载哔哩哔哩会员视频

[you-get 工具安装及使用教程 | typefo](https://typefo.com/tool/youget-tool-tutorial.html)

[soimort/you-get: Dumb downloader that scrapes the web](https://github.com/soimort/you-get#load-cookies)

用的是 Chrome，折腾半天，失败了

非得用 Firefox，真的是，还有不用 Chrome 的程序员

```shell
export cookies=/Users/zhangronghui/Library/Application\ Support/Google/Chrome/Default/Cookies
you-get -c $cookies https://www.bilibili.com/bangumi/play/ss23856/
```

期间，查看Chrome 的 cookies，用[sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser) 查看 sqlite 的内容；

用[Convert Google Chrome sqlite Cookies into cookies.txt. Useful for utilities like curl.](https://gist.github.com/nicerobot/1443588/a79d7842fd636b3c424e312205cedca854358c86) 转 cookie 为 txt 

```shell
sqlite3 -separator '  ' ${COOKIES:-Cookies} \
  'select host_key, "TRUE", path, "FALSE", expires_utc, name, value from cookies'
```



结果 you-get 需要分隔符为 tab

试了

```shell
sqlite3 -separator '\t' ${COOKIES:-Cookies} \
  'select host_key, "TRUE", path, "FALSE", expires_utc, name, value from cookies'
```

失败了，\t 不能被识别为 tab，解决办法：[osx - Simple sed replacement of tabs mysteriously failing - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/145299/simple-sed-replacement-of-tabs-mysteriously-failing)

```shell
export tab=$(printf '\t')
sqlite3 -separator $tab Cookies 'select host_key, "TRUE", path, "FALSE", expires_utc, name, value from cookies' > cookies.txt
```

结果还是不行，真的烦

## Linux

## Android

## win

# 生活

# 网址



[买房租房换房防套路必修课](http://www.chenf.net/thread-13061-1-1.html)

### **微信传文件到电脑

去打印室用

[收文件](http://www.shouwenjian.com/)



[北京邮电大学西土城路校区空闲教室查询](http://where-to-sleep.name1e5s.com/)
[淘口令解析](https://greasyfork.org/zh-CN/scripts/411432-%E6%B7%98%E5%8F%A3%E4%BB%A4%E8%A7%A3%E6%9E%90)
[TheFuture书籍搜索-免费电子书搜索引擎](https://bks.thefuture.top/?hao.su)



[blackjack4494/youtube-dlc: Command-line program to download various media from YouTube.com and other sites](https://github.com/blackjack4494/youtube-dlc)



[My WiFi Sign](https://www.mywifisign.com/zh-hans)
[JSON.link](https://json.link/)



[BT下载教程 篇四：qbittorrent 设置补充说明及更换WEB UI_NAS存储_什么值得买](https://post.smzdm.com/p/a3gwqd7k/)
[PT下载必读 |qBittorrent参数详细设置教程（保护硬盘） | PT邀请码网](http://www.ptyqm.com/26966.html)



### 给网站的美观性打个分

[How beautiful is your website ? | Myraah Visual Mind AI - Free Tool To Analyse Visual Quality Of your Website](https://myraah.io/index.php/visualmind)





[(2 条消息) Sony 1000xm3翻车的多吗？ - 知乎](https://www.zhihu.com/question/326309795)



![image-20200930124413743](https://i.loli.net/2020/09/30/QYFnPhuCmWItkya.png)












