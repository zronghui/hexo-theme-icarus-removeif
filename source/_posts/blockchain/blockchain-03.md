---
title: blockchain-03
toc: true
recommend: 1
uniqueId: '2020-04-30 02:41:30/"blockchain-03".html'
date: 2020-04-30 10:41:30
thumbnail:
categories:
- blockchain
tags:
keywords:
---

[TOC]

[北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://www.bilibili.com/video/av37065233)

<!--more-->

## P2. 02-BTC-密码学原理

比特币被称为加密货币crypto-currency
区块链上内容都是公开的，包括区块的地址，转账的金额。

**比特币主要用到了密码学中的两个功能:1.哈希2.签名**

### 哈希的性质

1.密码学中用到的哈希函数被称为cryptographic hash function:    它有**两个重要的性质**:
①**collision(这里指哈希碰撞) resistance**  :例如x≠y H(x)=H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。给出x，很难找到y，除非蛮力求解(brute-force)。
该性质的作用:对一个message求digest
比如message取m m的哈希值是H(m)=digest 如果有人想篡改m值而H(m)不变，则无法做到。
哈希碰撞无法人为制造，无法验证，是根据实践经验得来的。
②**hiding** 哈希函数的计算过程是单向的，不可逆的。(从H(x)无法推导出x) 

hiding性质前提是输入空间足够大，分布比较均匀。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。
该性质的作用:和collision resistance 结合在一起，用来实现digital commitment(又称为digital equivalent of a sealed envelope)
把预测结果作为输入x，算出一个哈希值，讲哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。

除了密码学中要求的这两个性质外，比特币中用到的哈希函数还有第三个性质:
③**puzzle friendly** 指哈希值的预算事先是不可预测的。假如哈希值是00...0XX...X，一样事先无法知道哪个值更容易算出这个结果，还是要一个一个带入。

比特币挖矿的过程中实际就是找一个nonce，nonce跟区块的块头里的其他信息合一起作为输入，得出的哈希值要小于等于某个指定的目标预值。H(block header)≤target。block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程是不停的试随机数，使得block header取哈希后落在指定的范围之内。

**puzzle friendly是指挖矿过程中没有捷径，为了使输出值落在指定范围，只能一个一个去试。所以这个过程还可以作为工作量证明(proof of work)。**
挖矿很难，验证很容易。(difficult to solve ,but easy to verify)

比特币中用的哈希函数叫作SHA-256(secure hash algorithm )以上三个性质它都是满足的。

### 非对称加密

2.
在比特币系统中开账户:
在本地创立一个公私钥匙对(public key ,private key)，这就是一个账户。公私钥匙对是来自于非对称的加密技术(asymmetric encryption algorithm)。

两人之间信息的交流可以利用密钥(encryption key)，A将信息加密后发给B，B收到后用密钥解密，因为加密和解密用的是同一个密钥，所以叫对称加密。前提是有渠道可以安全地把密钥分发给通讯的双方。因此**对称加密的缺点就是密钥的分发不方便**，因为在网络上很容易被窃听。非对称密钥是用一对密钥而不是一个，**加密用公钥，解密用私钥**，**加密和解密用的都是接收方的公钥和私钥**。公钥是不用保密的，私钥要保密但是私钥只要保存在本地就行，不用传给对方。公钥相当于银行账号，别人转账只要知道公钥就行，私钥相当于账户密码，知道私钥可以把账户上钱转走。**公钥和私钥是用来签名**。

假如A想向B转10个比特币，A把交易放在区块链上，别人怎么知道这笔交易是A发起的呢?这就需要A要用自己的私钥给交易签名，其他人收到这笔交易后，要用A的公钥去验证签名。**签名用私钥，验证用公钥**，用的仍然是同一个人的。创建账户产生相同公私钥的可能性微乎其微，所以大量创建账户来窃取其他人账户是不可行的。

我们假设产生公私钥时有一个好的随机源(a good source of randomness)，产生公私钥是随机的，如果随机源不好，就有可能产生相同的公私钥。比特币中用的签名算法，不仅是生成公私钥的时候要有好的随机源，之后每一次签名时也要有好的随机源。只要有一次签名用的随机源不好的话，就有可能泄露私钥。



## P3. 03-BTC-数据结构

### 区块链

普通指针存储的是某个结构体在内存中的地址。假如P是指向一结构体的指针，那么P里面存放的就是该结构体在内存中的起始位置。而**哈希指针除了要存地址之外，还要保存该结构体的哈希值H()**。好处是:从哈希值这个哈希指针，不仅可以找到该结构体的位置，同时还能够检测出该结构体的内容有没有被篡改，因为我们保存了它的哈希值。

比特币中最基本的结构就是区块链，区块链就是一个一个区块组成的链表。区块链和普通的链表相比有什么区别:
①用哈希指针代替了普通指针(B block chain is a linked list using hash pointers)

区块链第一个区块叫作创世纪块(genesis block) 最后一个区块 是最近产生的区块(most recent block) 每一个区块都包含指向前一个区块的哈希指针 
**一个区块的哈希指针**怎么算:是**把前面整个区块的内容，包括里面的hash pointer ，合在一起取哈希值**。通过这种结构，可以实现tamper-evident log。如果有人改变了一个区块的内容，后面一个区块的哈希指针就对不上，因为后一个区块哈希指针是根据前一个区块的内容算出来的，所以后一个哈希指针也得改，以此类推，我们保留的是最后一个哈希值也会变化。

②普通链表可以改变任意一个元素，对链表中其他元素是没有影响的。而区块链是牵一发而动全身，因为只需要保存最后一个哈希值，就可以判断区块链有没有改变，在哪里改变了。
因此**比特币没有必要保存所有区块的内容，可以只保留最近的几千个区块**。如果要用到以前的区块，可以向系统中其他节点要这个区块。有些节点是有恶意的，怎么判断?这里要用到哈希值一个性质，如下:
其他节点给你一个区块，如何判断它是正确的?算出它的哈希值，与保留的区块的哈希值对比，即可。

![NleqyYaMCPGwkQi](https://i.loli.net/2020/04/30/NleqyYaMCPGwkQi.png)

### Merkle tree



![N7cPSxBIbafMOer](https://i.loli.net/2020/04/30/N7cPSxBIbafMOer.png)





比特币中的另外一个结构是:Merkle tree。(其中最下面一层是数据块(data blocks)，上面三层内部节点都是哈希指针(hash pointers)，第一层是根节点，根节点的区块也可以取个哈希，叫根哈希(root hash))
另外一个概念:binary tree。

这种结构的好处:**只要记住根哈希值，就能检测出对树中任何部位的修改**。
它们的区别:①用哈希指针代替了普通指针。

比特币当中各区块之间用哈希指针连接在一起，每个区块所包含的交易组织成一个merkle tree的形式，最下面一行data blocks每个区块实际上是一个交易，每个区块分为两部分，分别是块头和块身(block header ,block body)。块头里面有根哈希值，每个区块所包含的所有交易组成的merkle tree的根哈希值存在于区块的块头里面，但是，块头里没有交易的具体内容，只有一个根哈希值，块身里面是有交易的列表的。

merkle tree 的作用:

①提供merkle proof 
比特币中的节点分为两类:全节点(保存整个区块的内容，即块头块身都有，有交易的具体信息)和轻节点(例如手机上的比特币钱包)(只有块头)

这时存在一个问题:**如何向一个轻节点证明某个交易是写入区块链**的?
这时需要用到merkle proof :找到交易所在的位置(最底行的其中一个区块)，这时该区块一直往上到根节点的路径就叫merkle proof。

![3ZtyJeNPQXLDgOm](https://i.loli.net/2020/04/30/3ZtyJeNPQXLDgOm.png)

最上面一行是小型的区块链，该图展现的是一个区块的merkle tree，最下面一行是包含的交易。假设某个轻节点想知道图中黄色的交易，是否包含在了merkle tree里面。该轻节点没有包含交易列表，没有这颗merkle tree的具体内容，只有一个根哈希值。这时轻节点向一个全节点发出请求，请求证明黄色的交易被包含在这颗merkle tree里面的merkle proof。全节点收到这个请求之后，只需要将图中标为红色的这三个哈希值发给轻节点即可。有了这些哈希值之后，轻节点可以在本地计算出图中标为绿色三个哈希值。首先算出黄色交易的哈希值，即它正上方的那个绿的哈希值，然后跟旁边红色的哈希值拼接起来，可以算出上层节点绿色的哈希值。然后再拼接，再算出上层绿色哈希值，再拼接，就可以算出整棵树的根哈希值。轻节点把这个根哈希值和block header里的根哈希值比较一下，就能知道黄色的交易是否在这颗merkle tree里。

全节点在merkle proof里提供的这几个哈希值，就是从黄色的交易所在的节点的位置到树根的路径上用到的这些哈希值。轻节点收到这样一个merkle proof之后，只要从下往上验证，沿途的哈希值都是正确的即可。(验证时只能验证该路径的哈希值，其他路径是验证不了的，即该图中红色的哈希值是验证不了的)

这样是否不安全呢?假如黄色交易被篡改，它的哈希值发生了变化，那能不能调整旁边红色的哈希值，使得它们拼接起来的哈希值是不变的呢?不行，根据collision resistance，这是不可行的。

merkle proof可以证明merkle tree里面包含了某个交易，所以这种证明又叫proof of membership或 proof of inclusion。
对于一个轻节点来说，**验证一个merkle proof 复杂度**是多少?假设最底层有n个交易，则merkle proof 复杂程度是**θ(log(n))**

**如何证明merkle tree里面没有包含某个交易**?即proof of non-membership。可以把整棵树传给轻节点，轻节点收到后验证树的构造都是对的，每一层用到的哈希值都是正确的，说明树里只有这些叶节点，要找的交易不在里面，就证明了proof of non-membership。问题在于，它的复杂度是线性的θ(n)，是比较笨的方法。

如果对叶节点的排列顺序做一些要求，比如**按照交易的哈希值排序**。每一个叶节点都是一次交易，对交易的内容取一次哈希，按照哈希值从小到大排列。要查的交易先算出一个哈希值，看看如果它在里面该是哪个位置。比如说在第三个第四个之间，这时提供的proof是第三个第四个叶节点都要往上到根节点。如果其中哈希值都是正确的，最后根节点算出的哈希值也是没有被改过的，说明第三、四个节点在原来的merkle tree里面，确实是相邻的点。要找的交易如果存在的话，应该在这两个节点中间。但是它没有出现，所以就不存在。其复杂度也是log形式，代价是要排序。排好序的叫作sorted merkle tree。**比特币中没有用到这种排好序的merkle tree，因为比特币中不需要做不存在证明**。



这节讲了比特币中两种最基本的结构:区块链和merkle tree，都是用哈希指针来构造的。除了这两种之外，哈希指针还能用另一个方面。

只要一个数据结构是无环的(非循环链表)，都能用哈希指针代替普通指针。有环的话存在一个问题，他们的哈希值没法计算

