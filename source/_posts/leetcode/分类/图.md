---
title: å›¾
toc: true
recommend: 1
uniqueId: '2020-08-01 04:03:59/"å›¾".html'
date: 2020-08-01 12:03:59
thumbnail:
categories:
- leetcode
- åˆ†ç±»
tags:
keywords:
---

[TOC]

<!--more-->

## æœ‰å‘å›¾ floyd ç®—æ³•

ç»éªŒï¼š

è‹¥æ±‚çš„æ˜¯ 2 ä¸ªèŠ‚ç‚¹ä¹‹é—´ï¼Œå¾€å¾€ç”¨ xfs æˆ– å¹¶æŸ¥é›†ï¼Œå› ä¸ºç”¨ Floyd çš„å¤æ‚åº¦è¿‡é«˜ï¼Œå¦‚[é¢è¯•é¢˜ 04.01. èŠ‚ç‚¹é—´é€šè·¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

è‹¥æ±‚çš„æ˜¯ queries (è¦æŸ¥è¯¢å¤šä¸ªèŠ‚ç‚¹å¯¹)ï¼Œè¿™æ—¶å€™ç”¨ flyod å¥½ä¸€ç‚¹ï¼Œå¦‚[1462. è¯¾ç¨‹å®‰æ’ IV - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/course-schedule-iv/)

### 1462. è¯¾ç¨‹å®‰æ’ IV - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1462. è¯¾ç¨‹å®‰æ’ IV - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/course-schedule-iv/)

```python
class Solution:
    def checkIfPrerequisite(self, n: int, pres: List[List[int]], qs: List[List[int]]) -> List[bool]:
        dp = [[False for _ in range(n)] for _ in range(n)]
        for a, b in pres: dp[a][b] = True
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dp[i][k] and dp[k][j]:
                        dp[i][j] = True
        return [dp[a][b] for a, b in qs]
```

### 743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/network-delay-time/submissions/)

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, S: int) -> int:
        dp = [[-1]*(N+1) for i in range(N+1)]
        for u, v, w in times:
            dp[u][v] = w
        for k in range(1, N+1):
            for i in range(1, N+1):
                for j in range(1, N+1):
                    if -1 not in (dp[i][k], dp[k][j]):
                        if -1==dp[i][j] or dp[i][j]>dp[i][k]+dp[k][j]:
                            dp[i][j] = dp[i][k]+dp[k][j]
        res = -1
        for i in range(1, N+1):
            if i==S: continue
            if -1==dp[S][i]: return -1
            res = max(res, dp[S][i])
        return res

```

### 1334. é˜ˆå€¼è·ç¦»å†…é‚»å±…æœ€å°‘çš„åŸå¸‚ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1334. é˜ˆå€¼è·ç¦»å†…é‚»å±…æœ€å°‘çš„åŸå¸‚ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/submissions/)

```python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        dp = [[float('inf')]*n for _ in range(n)]
        for i, j, w in edges:
            dp[i][j]=  w
            dp[j][i]=  w
        for k in range(n):
            for i in range(n):
                # if i==k: continue
                for j in range(n):
                    # if j in [k, j]: continue
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])
        l = [0 for _ in range(n)] # è¿é€šåŸå¸‚ä¸ªæ•°
        mi = -1
        m = float('inf')
        for i in range(n):
            for j in range(n):
                if j!=i and dp[i][j]<=distanceThreshold:
                    l[i] += 1
            if l[i]<=m:
                mi = i
                m = l[i]
        return mi
```



## æ— å‘å›¾ dijkstra ç®—æ³•

### 1514. æ¦‚ç‡æœ€å¤§çš„è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1514. æ¦‚ç‡æœ€å¤§çš„è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/path-with-maximum-probability/)

```python
class Solution:
    def maxProbability(self, n: int, e: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        # defaultdict æ„é€  graph
        graph = collections.defaultdict(dict)
        # å› ä¸ºè¿™ä¸ªé¢˜ç›®æ¯”è¾ƒç‰¹æ®Šï¼Œæƒé‡æ˜¯ä¹˜æ€§çš„å¹¶ä¸”0-1ä¹‹é—´ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ªdicè®°å½•ä»startå¼€å§‹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§æƒé‡ã€‚ ç„¶åæ¯æ¬¡ä½ åªéœ€è¦åˆ¤æ–­popå‡ºçš„èŠ‚ç‚¹çš„æƒé‡å°±å¯ä»¥ã€‚å¦‚æœæ¯”æ›¾ç»è®°å½•çš„dicä¸­çš„æƒé‡å°é‚£å°±æ²¡å¿…è¦ç»§ç»­ï¼ˆè¿™é‡Œé¢åŒ…å«äº†ç¯ï¼Œå›å¤´ï¼‰ï¼Œå¦‚æœæ¯”æ›¾ç»è®°å½•çš„æƒé‡å¤§ï¼Œé‚£ä¹ˆç»§ç»­è¿›è¡Œã€‚
        d = collections.defaultdict(float)
        for i in range(len(e)):
            p1, p2 = e[i]
            graph[p1][p2] = succProb[i]
            graph[p2][p1] = succProb[i]
        stack = collections.deque()
        stack.append([start, 1]) # start åˆ° å½“å‰ç‚¹ çš„ æ¦‚ç‡
        ans = 0
        while stack:
            cur, prob = stack.popleft()
            if cur==end:
                ans = max(ans, prob)
            elif prob>ans:
                for point, _prob in graph[cur].items():
                    if _prob*prob>ans and _prob*prob>d.get(point, 0):
                        d[point] = _prob*prob
                        stack.append([point, _prob*prob])
        return ans
```





## æ‹“æ‰‘æ’åº

### 207. è¯¾ç¨‹è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[207. è¯¾ç¨‹è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/course-schedule/)
[è¯¾ç¨‹è¡¨ï¼ˆæ‹“æ‰‘æ’åºï¼šå…¥åº¦è¡¨BFSæ³• / DFSæ³•ï¼Œæ¸…æ™°å›¾è§£ï¼‰ - è¯¾ç¨‹è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)
[æ‹“æ‰‘æ’åº_å“”å“©å“”å“© (ã‚œ-ã‚œ)ã¤ãƒ­ å¹²æ¯~-bilibili](https://www.bilibili.com/video/av17399461)

```python
class Solution:
    def canFinish(self, n: int, prerequisites: List[List[int]]) -> bool:
        indegrees, adjacency = [0 for _ in range(n)], [[] for _ in range(n)]
        for a, b in prerequisites:
            indegrees[b] += 1
            adjacency[a].append(b)
        queue = collections.deque()
        for i in range(n):
            if not indegrees[i]: queue.append(i)
        # path = []
        count = 0
        while queue:
            cur = queue.popleft()
            path.append(cur)
            count += 1
            for i in adjacency[cur]:
                indegrees[i] -= 1
                if not indegrees[i]: queue.append(i)
        # print(path)
        return count==n


```

### 210. è¯¾ç¨‹è¡¨ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[210. è¯¾ç¨‹è¡¨ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/course-schedule-ii/submissions/)

ä¾èµ–å…³ç³»åè¿‡æ¥äº†ï¼Œè€Œä¸”éœ€è¦è®°å½• pop çš„èŠ‚ç‚¹é¡ºåº

```python
class Solution:
    def findOrder(self, n: int, prerequisites: List[List[int]]) -> List[int]:
        indegrees, adjacency = [0 for _ in range(n)], [[] for _ in range(n)]
        for b, a in prerequisites:
            indegrees[b] += 1
            adjacency[a].append(b)
        queue = collections.deque()
        for i in range(n):
            if not indegrees[i]: queue.append(i)
        path = []
        count = 0
        while queue:
            cur = queue.popleft()
            path.append(cur)
            count += 1
            for i in adjacency[cur]:
                indegrees[i] -= 1
                if not indegrees[i]: queue.append(i)
        # print(path)
        return path if count==n else []


```



### 802 æ‰¾åˆ°æœ€ç»ˆçš„å®‰å…¨çŠ¶æ€ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[802. æ‰¾åˆ°æœ€ç»ˆçš„å®‰å…¨çŠ¶æ€ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/find-eventual-safe-states/submissions/)

[æ‹“æ‰‘æ’åºï¼šä»å‡ºåº¦ä¸º0çš„å¼§å°¾åå‘æ‹“æ‰‘åˆ°å¼§å¤´ï¼ˆmuyiï¼‰ - æ‰¾åˆ°æœ€ç»ˆçš„å®‰å…¨çŠ¶æ€ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/find-eventual-safe-states/solution/tuo-bu-pai-xu-cong-chu-du-wei-0de-hu-wei-fan-xiang/)

å®šä¹‰å®‰å…¨çš„ç‚¹ï¼šè·¯å¾„ç»ˆç‚¹ï¼Œä¹Ÿå°±æ˜¯å‡ºåº¦ä¸º0çš„ç‚¹

å®šä¹‰æœ€ç»ˆå®‰å…¨çš„ç‚¹ï¼šä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼Œå¯ä»¥æ²¿æŸä¸ªè·¯å¾„åˆ°è¾¾ç»ˆç‚¹ï¼Œé‚£ä¹ˆèµ·å§‹èŠ‚ç‚¹å°±æ˜¯æœ€ç»ˆå®‰å…¨çš„ç‚¹ã€‚

æ‰¾åˆ°å‡ºåº¦ä¸º0çš„é¡¶ç‚¹ï¼Œè¿™äº›ç‚¹æ˜¯å®‰å…¨çš„ç‚¹
é€†å‘åˆ é™¤ä»¥å‡ºåº¦ä¸º0çš„é¡¶ç‚¹ä¸ºå¼§å¤´çš„è¾¹ï¼Œå¼§å°¾çš„å‡ºåº¦å‡ä¸€
é‡å¤ä¸Šé¢ä¸¤æ­¥ï¼Œç›´åˆ°ä¸å­˜åœ¨å‡ºåº¦ä¸º0çš„é¡¶ç‚¹

```python
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        outdegrees, adjacency = [0 for _ in range(n)], [[] for _ in range(n)]
        for a in range(n):
            for b in graph[a]:
                outdegrees[a] += 1
                adjacency[b].append(a)
        queue = collections.deque()
        for i in range(n):
            if not outdegrees[i]: queue.append(i)
        path = []
        # count = 0
        while queue:
            cur = queue.popleft()
            path.append(cur)
            # count += 1
            for i in adjacency[cur]:
                outdegrees[i] -= 1
                if not outdegrees[i]: queue.append(i)
        # print(path)
        return sorted(path)
```

### 310. æœ€å°é«˜åº¦æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[310. æœ€å°é«˜åº¦æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/minimum-height-trees/submissions/)

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n<3: return list(range(n))
        # æ¯æ¬¡ç§»é™¤æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°ä¸ºç©ºï¼Œè¿”å›æœ€åä¸€æ¬¡éç©ºçš„åˆ—è¡¨
        # æœ€åä¸€æ¬¡éç©ºæ—¶ï¼ŒèŠ‚ç‚¹ä¸€å®šä¸å¤§äº 2 (ç­‰äº 3 æ—¶ï¼Œ ä¸€å®šæœ‰éå¶å­èŠ‚ç‚¹çš„èŠ‚ç‚¹)
        degrees = [0 for i in range(n)] # å…¥åº¦æˆ–å‡ºåº¦
        adjacency = [[] for i in range(n)]
        for i, j in edges:
            adjacency[i].append(j)
            adjacency[j].append(i)
            degrees[i] += 1
            degrees[j] += 1
        queue = collections.deque()
        s = set()
        for i in range(n):
            if degrees[i]==1:
                queue.append(i)
        while True:
            if n-len(s)<3: return list(set(range(n))-s)
            for t in range(len(queue)):
                i = queue.popleft()
                degrees[i] -= 1
                s.add(i)
                for j in adjacency[i]:
                    if j in s: continue
                    degrees[j] -= 1
                    if degrees[j]==1:
                        queue.append(j)

        
```



## å…¶ä»–

### 1042. ä¸é‚»æ¥æ¤èŠ± - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1042. ä¸é‚»æ¥æ¤èŠ± - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)

```python
from collections import defaultdict

class Solution:
    def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        def chooseone(exclude):
            for i in range(1, 5):
                if i not in exclude: return i

        m = defaultdict(list)
        for a, b in paths:
            m[a].append(b)
            m[b].append(a)
        res = [0]*N
        for i in m:
            res[i-1] = chooseone(exclude=[res[j-1] for j in m[i]])
        for i in range(N):
            if not res[i]: res[i] = 1
        return res


```

ç®€æ´å†™æ³•

```python
from collections import defaultdict

class Solution:
    def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        m = defaultdict(list)
        for a, b in paths:
            m[a-1].append(b-1)
            m[b-1].append(a-1)
        res = [0]*N
        for i in range(N):
            res[i] = ({1, 2, 3, 4}-{res[j] for j in m[i]}).pop()
        return res


```

### 997. æ‰¾åˆ°å°é•‡çš„æ³•å®˜ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[997. æ‰¾åˆ°å°é•‡çš„æ³•å®˜ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/find-the-town-judge/comments/)

æ™¦æ¶©çš„è§£æ³•

```python
class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        if not trust: 
            if N==1: return 1
            return -1
        # judge ä¸åœ¨ a ä¸­
        # judge å‡ºç° N-1 æ¬¡
        s = set(range(1, N+1))
        m = collections.defaultdict(int)
        for a, b in trust:
            m[b] += 1
            if a in s: s.remove(a)
        if not s or len(s)>1: return -1
        res = s.pop()
        if m[res]==N-1: return res
        return -1
```

[ã€ä¸€ä¸ªæ•°ç»„æå®šã€‘é€šä¿—æ˜“æ‡‚ï¼ˆ997. æ‰¾åˆ°å°é•‡çš„æ³•å®˜ï¼‰ - æ‰¾åˆ°å°é•‡çš„æ³•å®˜ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/find-the-town-judge/solution/yi-ge-shu-zu-gao-ding-tong-su-yi-dong-997-zhao-dao/)

æ³•å®˜ğŸ‘©â€âš–ï¸ å®é™…ä¸Šå°±æ˜¯å‡ºåº¦ä¸º0ï¼Œå…¥åº¦ä¸º N - 1çš„èŠ‚ç‚¹ã€‚è¿™å›ºç„¶æ²¡é”™ï¼Œç„¶è€Œæˆ‘ä»¬ä»ç„¶å¯ä»¥æ¢ä¸ªè§’åº¦æ¥æ€è€ƒï¼Œæ³•å®˜ğŸ‘©â€âš–ï¸ åŒæ ·æ˜¯ å…¥åº¦ - å‡ºåº¦ == N - 1 çš„ç‚¹ï¼Œå¹¶ä¸”ä¸æ˜¯æ³•å®˜çš„äººä¸å¯èƒ½æ˜¯ã€‚

```python
class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        l = [0]*N
        for a, b in trust:
            l[a-1] -= 1
            l[b-1] += 1
        for i in range(N):
            if l[i]==N-1: return i+1
        return -1
```

### 841. é’¥åŒ™å’Œæˆ¿é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[841. é’¥åŒ™å’Œæˆ¿é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/keys-and-rooms/submissions/)

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        # ä» 0 æ˜¯å¦å…¨éƒ¨è¿é€šå…¶ä»–ç‚¹
        visited, queue = set(), [0]
        while queue:
            cur = queue.pop()
            if cur in visited: continue
            visited.add(cur)
            queue.extend(rooms[cur])
        return set(range(len(rooms)))==visited

        
```

### 1267. ç»Ÿè®¡å‚ä¸é€šä¿¡çš„æœåŠ¡å™¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1267. ç»Ÿè®¡å‚ä¸é€šä¿¡çš„æœåŠ¡å™¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/count-servers-that-communicate/submissions/)

æš´åŠ›

```python
from collections import defaultdict
class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        res = 0
        rows, cols = defaultdict(int), defaultdict(int)
        n, m = len(grid), len(grid[0])
        for i in range(n):
            for j in range(m):
                if grid[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        for i in range(n):
            for j in range(m):
                if grid[i][j]:
                    if max(rows[i], cols[j])>1:
                        res += 1
        return res
```

### 133. å…‹éš†å›¾ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[133. å…‹éš†å›¾ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/clone-graph/submissions/)
[DFS å’Œ BFS - å…‹éš†å›¾ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/clone-graph/solution/dfs-he-bfs-by-powcai/)

dfs

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = []):
        self.val = val
        self.neighbors = neighbors
"""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        d = {}

        def dfs(node):
            if node in d: return d[node]
            clone = Node(node.val)
            d[node] = clone
            for neighbor in node.neighbors:
                clone.neighbors.append(dfs(neighbor))
            # d[node] = clone æ”¾è¿™é‡Œ    â†‘ dfs ä¸æ–­é€’å½’è°ƒç”¨
            return clone

        return dfs(node) if node else None
        
```

### 1306. è·³è·ƒæ¸¸æˆ III - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1306. è·³è·ƒæ¸¸æˆ III - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/jump-game-iii/)

floyd è¶…æ—¶ ç”¨ bfs è§£å†³

#### Floyd

```python
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0: return True
        # æœ‰å‘å›¾ åˆ¤æ–­ start åˆ° 0 å¤„æ˜¯å¦å¯è¾¾
        n = len(arr)
        i0 = [] # 0 çš„ index
        dp = [[False]*n for _ in range(n)]
        for i in range(n):
            if arr[i]==0:
                i0.append(i)
                continue
            if i+arr[i]<n:
                dp[i][i+arr[i]] = True
            if i-arr[i]>=0:
                dp[i][i-arr[i]] = True
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dp[i][k] and dp[k][j]:
                        dp[i][j] = True
        for i in i0:
            if dp[start][i]:
                return True
        return False
```

#### bfs

```python
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n = len(arr)
        visited = set()
        deque = [start]
        while deque:
            cur = deque.pop()
            if arr[cur]==0: return True
            if cur in visited: continue
            visited.add(cur)
            for nxt in [cur+arr[cur], cur-arr[cur]]:
                if 0<=nxt<n and nxt not in visited:
                    deque.append(nxt)
            # print(visited, deque)
        return False
```

### é¢è¯•é¢˜ 04.01. èŠ‚ç‚¹é—´é€šè·¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[é¢è¯•é¢˜ 04.01. èŠ‚ç‚¹é—´é€šè·¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

flyod è¶…æ—¶

```python
class Solution:
    def findWhetherExistsPath(self, n: int, graph: List[List[int]], start: int, target: int) -> bool:
        dp = [[False]*n for _ in range(n)]
        for i, j in graph:
            dp[i][j] = True
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dp[i][k] and dp[k][j]:
                        dp[i][j] = True
        return dp[start][target]
```

~~xfs~~ dfs

```python
class Solution:
    def findWhetherExistsPath(self, n: int, graph: List[List[int]], start: int, target: int) -> bool:
        visited = set()
        m = collections.defaultdict(set)
        for i, j in graph:
            m[i].add(j)
        queue = [start]
        while queue:
            cur = queue.pop()
            if cur in visited: continue
            visited.add(cur)
            if cur==target: return True
            for i in m[cur]:
                if i not in visited:
                    queue.append(i)
        return False
```

### 1361. éªŒè¯äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1361. éªŒè¯äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/validate-binary-tree-nodes/submissions/)

```python
class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        # æ‰€æœ‰èŠ‚ç‚¹å…¥åº¦ä¸º 1ï¼Œ é™¤äº† 1 ä¸ªèŠ‚ç‚¹æ²¡æœ‰å…¥åº¦ï¼ˆrootï¼‰
        # ç„¶åä» root å¼€å§‹éå†ï¼Œè‹¥èƒ½æ— ç¯åœ°éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œåˆ™æ»¡è¶³æ¡ä»¶
        indegrees = [0 for i in range(n)]
        for i in range(n):
            left, right = leftChild[i], rightChild[i]
            if -1!=left: indegrees[left] += 1
            if -1!=right: indegrees[right] += 1
            if max(indegrees[left], indegrees[right])>1: return False
        cnt = 0
        root = 0
        for i in range(n):
            if indegrees[i]==0: 
                cnt += 1
                root = i
                if cnt>1: return False
        if cnt==0: return False
        
        s = set()
        queue = collections.deque()
        queue.append(root)
        while queue:
            cur = queue.popleft()
            if cur in s: return False # å·²ç»éå†è¿‡ï¼Œè¯´æ˜æœ‰ç¯
            s.add(cur)
            if leftChild[cur]!=-1: queue.append(leftChild[cur])
            if rightChild[cur]!=-1: queue.append(rightChild[cur])
        return len(s)==n
```

### 1162. åœ°å›¾åˆ†æ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰

[1162. åœ°å›¾åˆ†æ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode-cn.com/problems/as-far-from-land-as-possible/submissions/)

bfs

python æ— æ³•è·³å‡ºæŒ‡å®šçš„å¤–å±‚ loopï¼Œå¯ä»¥ç”¨å‡½æ•° return å®ç°åŒæ ·çš„æ•ˆæœï¼Œä¸”ä»£ç æ›´æ¸…æ™°

```python
class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        res = -1
        n = len(grid)

        def valid(i, j):
            return 0<=i<n and 0<=j<n and grid[i][j]

        def maxDis(i, j):
            for dis in range(1, 2*n):
                for x in range(dis+1):
                    y = dis-x
                    if any([valid(i+x, j+y), valid(i+x, j-y), valid(i-x, j+y), valid(i-x, j-y)]):
                        return dis
            return -1

        for i in range(n):
            for j in range(n):
                if grid[i][j]: continue
                # cur = -1
                res = max(res, maxDis(i, j))
                # print(i, j, maxDis(i, j))
        return res
```





